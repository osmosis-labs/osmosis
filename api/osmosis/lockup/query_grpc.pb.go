// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: osmosis/lockup/query.proto

package lockup

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// Return full balance of the module
	ModuleBalance(ctx context.Context, in *ModuleBalanceRequest, opts ...grpc.CallOption) (*ModuleBalanceResponse, error)
	// Return locked balance of the module
	ModuleLockedAmount(ctx context.Context, in *ModuleLockedAmountRequest, opts ...grpc.CallOption) (*ModuleLockedAmountResponse, error)
	// Returns unlockable coins which are not withdrawn yet
	AccountUnlockableCoins(ctx context.Context, in *AccountUnlockableCoinsRequest, opts ...grpc.CallOption) (*AccountUnlockableCoinsResponse, error)
	// Returns unlocking coins
	AccountUnlockingCoins(ctx context.Context, in *AccountUnlockingCoinsRequest, opts ...grpc.CallOption) (*AccountUnlockingCoinsResponse, error)
	// Return a locked coins that can't be withdrawn
	AccountLockedCoins(ctx context.Context, in *AccountLockedCoinsRequest, opts ...grpc.CallOption) (*AccountLockedCoinsResponse, error)
	// Returns locked records of an account with unlock time beyond timestamp
	AccountLockedPastTime(ctx context.Context, in *AccountLockedPastTimeRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeResponse, error)
	// Returns locked records of an account with unlock time beyond timestamp
	// excluding tokens started unlocking
	AccountLockedPastTimeNotUnlockingOnly(ctx context.Context, in *AccountLockedPastTimeNotUnlockingOnlyRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeNotUnlockingOnlyResponse, error)
	// Returns unlocked records with unlock time before timestamp
	AccountUnlockedBeforeTime(ctx context.Context, in *AccountUnlockedBeforeTimeRequest, opts ...grpc.CallOption) (*AccountUnlockedBeforeTimeResponse, error)
	// Returns lock records by address, timestamp, denom
	AccountLockedPastTimeDenom(ctx context.Context, in *AccountLockedPastTimeDenomRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeDenomResponse, error)
	// Returns total locked per denom with longer past given time
	LockedDenom(ctx context.Context, in *LockedDenomRequest, opts ...grpc.CallOption) (*LockedDenomResponse, error)
	// Returns lock record by id
	LockedByID(ctx context.Context, in *LockedRequest, opts ...grpc.CallOption) (*LockedResponse, error)
	// Returns synthetic lockups by native lockup id
	SyntheticLockupsByLockupID(ctx context.Context, in *SyntheticLockupsByLockupIDRequest, opts ...grpc.CallOption) (*SyntheticLockupsByLockupIDResponse, error)
	// Returns account locked records with longer duration
	AccountLockedLongerDuration(ctx context.Context, in *AccountLockedLongerDurationRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationResponse, error)
	// Returns account locked records with a specific duration
	AccountLockedDuration(ctx context.Context, in *AccountLockedDurationRequest, opts ...grpc.CallOption) (*AccountLockedDurationResponse, error)
	// Returns account locked records with longer duration excluding tokens
	// started unlocking
	AccountLockedLongerDurationNotUnlockingOnly(ctx context.Context, in *AccountLockedLongerDurationNotUnlockingOnlyRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationNotUnlockingOnlyResponse, error)
	// Returns account's locked records for a denom with longer duration
	AccountLockedLongerDurationDenom(ctx context.Context, in *AccountLockedLongerDurationDenomRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationDenomResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) ModuleBalance(ctx context.Context, in *ModuleBalanceRequest, opts ...grpc.CallOption) (*ModuleBalanceResponse, error) {
	out := new(ModuleBalanceResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/ModuleBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ModuleLockedAmount(ctx context.Context, in *ModuleLockedAmountRequest, opts ...grpc.CallOption) (*ModuleLockedAmountResponse, error) {
	out := new(ModuleLockedAmountResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/ModuleLockedAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountUnlockableCoins(ctx context.Context, in *AccountUnlockableCoinsRequest, opts ...grpc.CallOption) (*AccountUnlockableCoinsResponse, error) {
	out := new(AccountUnlockableCoinsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountUnlockableCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountUnlockingCoins(ctx context.Context, in *AccountUnlockingCoinsRequest, opts ...grpc.CallOption) (*AccountUnlockingCoinsResponse, error) {
	out := new(AccountUnlockingCoinsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountUnlockingCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedCoins(ctx context.Context, in *AccountLockedCoinsRequest, opts ...grpc.CallOption) (*AccountLockedCoinsResponse, error) {
	out := new(AccountLockedCoinsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedCoins", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedPastTime(ctx context.Context, in *AccountLockedPastTimeRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeResponse, error) {
	out := new(AccountLockedPastTimeResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedPastTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedPastTimeNotUnlockingOnly(ctx context.Context, in *AccountLockedPastTimeNotUnlockingOnlyRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeNotUnlockingOnlyResponse, error) {
	out := new(AccountLockedPastTimeNotUnlockingOnlyResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedPastTimeNotUnlockingOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountUnlockedBeforeTime(ctx context.Context, in *AccountUnlockedBeforeTimeRequest, opts ...grpc.CallOption) (*AccountUnlockedBeforeTimeResponse, error) {
	out := new(AccountUnlockedBeforeTimeResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountUnlockedBeforeTime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedPastTimeDenom(ctx context.Context, in *AccountLockedPastTimeDenomRequest, opts ...grpc.CallOption) (*AccountLockedPastTimeDenomResponse, error) {
	out := new(AccountLockedPastTimeDenomResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedPastTimeDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LockedDenom(ctx context.Context, in *LockedDenomRequest, opts ...grpc.CallOption) (*LockedDenomResponse, error) {
	out := new(LockedDenomResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/LockedDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) LockedByID(ctx context.Context, in *LockedRequest, opts ...grpc.CallOption) (*LockedResponse, error) {
	out := new(LockedResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/LockedByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SyntheticLockupsByLockupID(ctx context.Context, in *SyntheticLockupsByLockupIDRequest, opts ...grpc.CallOption) (*SyntheticLockupsByLockupIDResponse, error) {
	out := new(SyntheticLockupsByLockupIDResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/SyntheticLockupsByLockupID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedLongerDuration(ctx context.Context, in *AccountLockedLongerDurationRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationResponse, error) {
	out := new(AccountLockedLongerDurationResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedLongerDuration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedDuration(ctx context.Context, in *AccountLockedDurationRequest, opts ...grpc.CallOption) (*AccountLockedDurationResponse, error) {
	out := new(AccountLockedDurationResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedDuration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedLongerDurationNotUnlockingOnly(ctx context.Context, in *AccountLockedLongerDurationNotUnlockingOnlyRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationNotUnlockingOnlyResponse, error) {
	out := new(AccountLockedLongerDurationNotUnlockingOnlyResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedLongerDurationNotUnlockingOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AccountLockedLongerDurationDenom(ctx context.Context, in *AccountLockedLongerDurationDenomRequest, opts ...grpc.CallOption) (*AccountLockedLongerDurationDenomResponse, error) {
	out := new(AccountLockedLongerDurationDenomResponse)
	err := c.cc.Invoke(ctx, "/osmosis.lockup.Query/AccountLockedLongerDurationDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	// Return full balance of the module
	ModuleBalance(context.Context, *ModuleBalanceRequest) (*ModuleBalanceResponse, error)
	// Return locked balance of the module
	ModuleLockedAmount(context.Context, *ModuleLockedAmountRequest) (*ModuleLockedAmountResponse, error)
	// Returns unlockable coins which are not withdrawn yet
	AccountUnlockableCoins(context.Context, *AccountUnlockableCoinsRequest) (*AccountUnlockableCoinsResponse, error)
	// Returns unlocking coins
	AccountUnlockingCoins(context.Context, *AccountUnlockingCoinsRequest) (*AccountUnlockingCoinsResponse, error)
	// Return a locked coins that can't be withdrawn
	AccountLockedCoins(context.Context, *AccountLockedCoinsRequest) (*AccountLockedCoinsResponse, error)
	// Returns locked records of an account with unlock time beyond timestamp
	AccountLockedPastTime(context.Context, *AccountLockedPastTimeRequest) (*AccountLockedPastTimeResponse, error)
	// Returns locked records of an account with unlock time beyond timestamp
	// excluding tokens started unlocking
	AccountLockedPastTimeNotUnlockingOnly(context.Context, *AccountLockedPastTimeNotUnlockingOnlyRequest) (*AccountLockedPastTimeNotUnlockingOnlyResponse, error)
	// Returns unlocked records with unlock time before timestamp
	AccountUnlockedBeforeTime(context.Context, *AccountUnlockedBeforeTimeRequest) (*AccountUnlockedBeforeTimeResponse, error)
	// Returns lock records by address, timestamp, denom
	AccountLockedPastTimeDenom(context.Context, *AccountLockedPastTimeDenomRequest) (*AccountLockedPastTimeDenomResponse, error)
	// Returns total locked per denom with longer past given time
	LockedDenom(context.Context, *LockedDenomRequest) (*LockedDenomResponse, error)
	// Returns lock record by id
	LockedByID(context.Context, *LockedRequest) (*LockedResponse, error)
	// Returns synthetic lockups by native lockup id
	SyntheticLockupsByLockupID(context.Context, *SyntheticLockupsByLockupIDRequest) (*SyntheticLockupsByLockupIDResponse, error)
	// Returns account locked records with longer duration
	AccountLockedLongerDuration(context.Context, *AccountLockedLongerDurationRequest) (*AccountLockedLongerDurationResponse, error)
	// Returns account locked records with a specific duration
	AccountLockedDuration(context.Context, *AccountLockedDurationRequest) (*AccountLockedDurationResponse, error)
	// Returns account locked records with longer duration excluding tokens
	// started unlocking
	AccountLockedLongerDurationNotUnlockingOnly(context.Context, *AccountLockedLongerDurationNotUnlockingOnlyRequest) (*AccountLockedLongerDurationNotUnlockingOnlyResponse, error)
	// Returns account's locked records for a denom with longer duration
	AccountLockedLongerDurationDenom(context.Context, *AccountLockedLongerDurationDenomRequest) (*AccountLockedLongerDurationDenomResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) ModuleBalance(context.Context, *ModuleBalanceRequest) (*ModuleBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleBalance not implemented")
}
func (UnimplementedQueryServer) ModuleLockedAmount(context.Context, *ModuleLockedAmountRequest) (*ModuleLockedAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleLockedAmount not implemented")
}
func (UnimplementedQueryServer) AccountUnlockableCoins(context.Context, *AccountUnlockableCoinsRequest) (*AccountUnlockableCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountUnlockableCoins not implemented")
}
func (UnimplementedQueryServer) AccountUnlockingCoins(context.Context, *AccountUnlockingCoinsRequest) (*AccountUnlockingCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountUnlockingCoins not implemented")
}
func (UnimplementedQueryServer) AccountLockedCoins(context.Context, *AccountLockedCoinsRequest) (*AccountLockedCoinsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedCoins not implemented")
}
func (UnimplementedQueryServer) AccountLockedPastTime(context.Context, *AccountLockedPastTimeRequest) (*AccountLockedPastTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedPastTime not implemented")
}
func (UnimplementedQueryServer) AccountLockedPastTimeNotUnlockingOnly(context.Context, *AccountLockedPastTimeNotUnlockingOnlyRequest) (*AccountLockedPastTimeNotUnlockingOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedPastTimeNotUnlockingOnly not implemented")
}
func (UnimplementedQueryServer) AccountUnlockedBeforeTime(context.Context, *AccountUnlockedBeforeTimeRequest) (*AccountUnlockedBeforeTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountUnlockedBeforeTime not implemented")
}
func (UnimplementedQueryServer) AccountLockedPastTimeDenom(context.Context, *AccountLockedPastTimeDenomRequest) (*AccountLockedPastTimeDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedPastTimeDenom not implemented")
}
func (UnimplementedQueryServer) LockedDenom(context.Context, *LockedDenomRequest) (*LockedDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockedDenom not implemented")
}
func (UnimplementedQueryServer) LockedByID(context.Context, *LockedRequest) (*LockedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockedByID not implemented")
}
func (UnimplementedQueryServer) SyntheticLockupsByLockupID(context.Context, *SyntheticLockupsByLockupIDRequest) (*SyntheticLockupsByLockupIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyntheticLockupsByLockupID not implemented")
}
func (UnimplementedQueryServer) AccountLockedLongerDuration(context.Context, *AccountLockedLongerDurationRequest) (*AccountLockedLongerDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedLongerDuration not implemented")
}
func (UnimplementedQueryServer) AccountLockedDuration(context.Context, *AccountLockedDurationRequest) (*AccountLockedDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedDuration not implemented")
}
func (UnimplementedQueryServer) AccountLockedLongerDurationNotUnlockingOnly(context.Context, *AccountLockedLongerDurationNotUnlockingOnlyRequest) (*AccountLockedLongerDurationNotUnlockingOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedLongerDurationNotUnlockingOnly not implemented")
}
func (UnimplementedQueryServer) AccountLockedLongerDurationDenom(context.Context, *AccountLockedLongerDurationDenomRequest) (*AccountLockedLongerDurationDenomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountLockedLongerDurationDenom not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_ModuleBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ModuleBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/ModuleBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ModuleBalance(ctx, req.(*ModuleBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ModuleLockedAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleLockedAmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ModuleLockedAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/ModuleLockedAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ModuleLockedAmount(ctx, req.(*ModuleLockedAmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountUnlockableCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountUnlockableCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountUnlockableCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountUnlockableCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountUnlockableCoins(ctx, req.(*AccountUnlockableCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountUnlockingCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountUnlockingCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountUnlockingCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountUnlockingCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountUnlockingCoins(ctx, req.(*AccountUnlockingCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedCoins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedCoinsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedCoins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedCoins",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedCoins(ctx, req.(*AccountLockedCoinsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedPastTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedPastTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedPastTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedPastTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedPastTime(ctx, req.(*AccountLockedPastTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedPastTimeNotUnlockingOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedPastTimeNotUnlockingOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedPastTimeNotUnlockingOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedPastTimeNotUnlockingOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedPastTimeNotUnlockingOnly(ctx, req.(*AccountLockedPastTimeNotUnlockingOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountUnlockedBeforeTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountUnlockedBeforeTimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountUnlockedBeforeTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountUnlockedBeforeTime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountUnlockedBeforeTime(ctx, req.(*AccountUnlockedBeforeTimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedPastTimeDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedPastTimeDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedPastTimeDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedPastTimeDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedPastTimeDenom(ctx, req.(*AccountLockedPastTimeDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LockedDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockedDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LockedDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/LockedDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LockedDenom(ctx, req.(*LockedDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_LockedByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).LockedByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/LockedByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).LockedByID(ctx, req.(*LockedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SyntheticLockupsByLockupID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyntheticLockupsByLockupIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SyntheticLockupsByLockupID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/SyntheticLockupsByLockupID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SyntheticLockupsByLockupID(ctx, req.(*SyntheticLockupsByLockupIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedLongerDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedLongerDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedLongerDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedLongerDuration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedLongerDuration(ctx, req.(*AccountLockedLongerDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedDuration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedDuration(ctx, req.(*AccountLockedDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedLongerDurationNotUnlockingOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedLongerDurationNotUnlockingOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedLongerDurationNotUnlockingOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedLongerDurationNotUnlockingOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedLongerDurationNotUnlockingOnly(ctx, req.(*AccountLockedLongerDurationNotUnlockingOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AccountLockedLongerDurationDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountLockedLongerDurationDenomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AccountLockedLongerDurationDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.lockup.Query/AccountLockedLongerDurationDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AccountLockedLongerDurationDenom(ctx, req.(*AccountLockedLongerDurationDenomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "osmosis.lockup.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ModuleBalance",
			Handler:    _Query_ModuleBalance_Handler,
		},
		{
			MethodName: "ModuleLockedAmount",
			Handler:    _Query_ModuleLockedAmount_Handler,
		},
		{
			MethodName: "AccountUnlockableCoins",
			Handler:    _Query_AccountUnlockableCoins_Handler,
		},
		{
			MethodName: "AccountUnlockingCoins",
			Handler:    _Query_AccountUnlockingCoins_Handler,
		},
		{
			MethodName: "AccountLockedCoins",
			Handler:    _Query_AccountLockedCoins_Handler,
		},
		{
			MethodName: "AccountLockedPastTime",
			Handler:    _Query_AccountLockedPastTime_Handler,
		},
		{
			MethodName: "AccountLockedPastTimeNotUnlockingOnly",
			Handler:    _Query_AccountLockedPastTimeNotUnlockingOnly_Handler,
		},
		{
			MethodName: "AccountUnlockedBeforeTime",
			Handler:    _Query_AccountUnlockedBeforeTime_Handler,
		},
		{
			MethodName: "AccountLockedPastTimeDenom",
			Handler:    _Query_AccountLockedPastTimeDenom_Handler,
		},
		{
			MethodName: "LockedDenom",
			Handler:    _Query_LockedDenom_Handler,
		},
		{
			MethodName: "LockedByID",
			Handler:    _Query_LockedByID_Handler,
		},
		{
			MethodName: "SyntheticLockupsByLockupID",
			Handler:    _Query_SyntheticLockupsByLockupID_Handler,
		},
		{
			MethodName: "AccountLockedLongerDuration",
			Handler:    _Query_AccountLockedLongerDuration_Handler,
		},
		{
			MethodName: "AccountLockedDuration",
			Handler:    _Query_AccountLockedDuration_Handler,
		},
		{
			MethodName: "AccountLockedLongerDurationNotUnlockingOnly",
			Handler:    _Query_AccountLockedLongerDurationNotUnlockingOnly_Handler,
		},
		{
			MethodName: "AccountLockedLongerDurationDenom",
			Handler:    _Query_AccountLockedLongerDurationDenom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "osmosis/lockup/query.proto",
}
