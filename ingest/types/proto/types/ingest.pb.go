// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osmosis/ingest/v1beta1/ingest.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PoolData represents a structure encapsulating an Osmosis liquidity pool.
type PoolData struct {
	// ChainModel is the chain representation model of the pool.
	ChainModel []byte `protobuf:"bytes,1,opt,name=chain_model,json=chainModel,proto3" json:"chain_model,omitempty"`
	// SqsModel is additional pool data used by the sidecar query server.
	SqsModel []byte `protobuf:"bytes,2,opt,name=sqs_model,json=sqsModel,proto3" json:"sqs_model,omitempty"`
	// TickModel is the tick data of a concentrated liquidity pool.
	// This field is only valid and set for concentrated pools. It is nil
	// otherwise.
	TickModel []byte `protobuf:"bytes,3,opt,name=tick_model,json=tickModel,proto3" json:"tick_model,omitempty"`
}

func (m *PoolData) Reset()         { *m = PoolData{} }
func (m *PoolData) String() string { return proto.CompactTextString(m) }
func (*PoolData) ProtoMessage()    {}
func (*PoolData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc800754937f999, []int{0}
}
func (m *PoolData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolData.Merge(m, src)
}
func (m *PoolData) XXX_Size() int {
	return m.Size()
}
func (m *PoolData) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolData.DiscardUnknown(m)
}

var xxx_messageInfo_PoolData proto.InternalMessageInfo

func (m *PoolData) GetChainModel() []byte {
	if m != nil {
		return m.ChainModel
	}
	return nil
}

func (m *PoolData) GetSqsModel() []byte {
	if m != nil {
		return m.SqsModel
	}
	return nil
}

func (m *PoolData) GetTickModel() []byte {
	if m != nil {
		return m.TickModel
	}
	return nil
}

// The block process request.
// Sends taker fees, block height and pools.
type ProcessBlockRequest struct {
	// block height is the height of the block being processed.
	BlockHeight uint64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// taker_fees_map is the map of taker fees for the block.
	TakerFeesMap []byte `protobuf:"bytes,2,opt,name=taker_fees_map,json=takerFeesMap,proto3" json:"taker_fees_map,omitempty"`
	// pools in the block.
	Pools []*PoolData `protobuf:"bytes,3,rep,name=pools,proto3" json:"pools,omitempty"`
}

func (m *ProcessBlockRequest) Reset()         { *m = ProcessBlockRequest{} }
func (m *ProcessBlockRequest) String() string { return proto.CompactTextString(m) }
func (*ProcessBlockRequest) ProtoMessage()    {}
func (*ProcessBlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc800754937f999, []int{1}
}
func (m *ProcessBlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessBlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessBlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessBlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessBlockRequest.Merge(m, src)
}
func (m *ProcessBlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProcessBlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessBlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessBlockRequest proto.InternalMessageInfo

func (m *ProcessBlockRequest) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ProcessBlockRequest) GetTakerFeesMap() []byte {
	if m != nil {
		return m.TakerFeesMap
	}
	return nil
}

func (m *ProcessBlockRequest) GetPools() []*PoolData {
	if m != nil {
		return m.Pools
	}
	return nil
}

// The response after completing the block processing.
type ProcessBlockReply struct {
}

func (m *ProcessBlockReply) Reset()         { *m = ProcessBlockReply{} }
func (m *ProcessBlockReply) String() string { return proto.CompactTextString(m) }
func (*ProcessBlockReply) ProtoMessage()    {}
func (*ProcessBlockReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_1fc800754937f999, []int{2}
}
func (m *ProcessBlockReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessBlockReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessBlockReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessBlockReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessBlockReply.Merge(m, src)
}
func (m *ProcessBlockReply) XXX_Size() int {
	return m.Size()
}
func (m *ProcessBlockReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessBlockReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessBlockReply proto.InternalMessageInfo

func init() {
	proto.RegisterType((*PoolData)(nil), "osmosis.ingest.v1beta1.PoolData")
	proto.RegisterType((*ProcessBlockRequest)(nil), "osmosis.ingest.v1beta1.ProcessBlockRequest")
	proto.RegisterType((*ProcessBlockReply)(nil), "osmosis.ingest.v1beta1.ProcessBlockReply")
}

func init() {
	proto.RegisterFile("osmosis/ingest/v1beta1/ingest.proto", fileDescriptor_1fc800754937f999)
}

var fileDescriptor_1fc800754937f999 = []byte{
	// 351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0x41, 0x4b, 0xeb, 0x40,
	0x14, 0x85, 0x93, 0xd7, 0xf7, 0x1e, 0xed, 0x24, 0x08, 0x4e, 0x41, 0x8a, 0x62, 0xac, 0xd1, 0x45,
	0x45, 0x4c, 0x6c, 0x0b, 0xae, 0x5c, 0x15, 0x11, 0x5d, 0x14, 0x6a, 0x0a, 0x2e, 0xdc, 0x84, 0x49,
	0xbc, 0x26, 0xa1, 0x49, 0x27, 0xcd, 0x9d, 0x56, 0xfa, 0x2f, 0x5c, 0xf9, 0x9b, 0x5c, 0x76, 0xe9,
	0x52, 0xda, 0x3f, 0x22, 0x9d, 0x4e, 0x41, 0x51, 0xc1, 0x5d, 0xce, 0x77, 0x4e, 0xee, 0x9d, 0xc3,
	0x0c, 0x39, 0xe0, 0x98, 0x71, 0x4c, 0xd0, 0x4d, 0x86, 0x11, 0xa0, 0x70, 0x27, 0xcd, 0x00, 0x04,
	0x6b, 0x2a, 0xe9, 0xe4, 0x05, 0x17, 0x9c, 0x6e, 0xa9, 0x90, 0xa3, 0xa8, 0x0a, 0xd9, 0x11, 0x29,
	0xf7, 0x38, 0x4f, 0x2f, 0x98, 0x60, 0x74, 0x8f, 0x18, 0x61, 0xcc, 0x92, 0xa1, 0x9f, 0xf1, 0x7b,
	0x48, 0x6b, 0x7a, 0x5d, 0x6f, 0x98, 0x1e, 0x91, 0xa8, 0xbb, 0x24, 0x74, 0x87, 0x54, 0x70, 0x84,
	0xca, 0xfe, 0x23, 0xed, 0x32, 0x8e, 0x70, 0x65, 0xee, 0x12, 0x22, 0x92, 0x70, 0xa0, 0xdc, 0x92,
	0x74, 0x2b, 0x4b, 0x22, 0x6d, 0xfb, 0x59, 0x27, 0xd5, 0x5e, 0xc1, 0x43, 0x40, 0xec, 0xa4, 0x3c,
	0x1c, 0x78, 0x30, 0x1a, 0x03, 0x0a, 0xba, 0x4f, 0xcc, 0x60, 0xa9, 0xfd, 0x18, 0x92, 0x28, 0x16,
	0x72, 0xeb, 0x5f, 0xcf, 0x90, 0xec, 0x4a, 0x22, 0x7a, 0x48, 0x36, 0x04, 0x1b, 0x40, 0xe1, 0x3f,
	0x00, 0xa0, 0x9f, 0xb1, 0x5c, 0xed, 0x36, 0x25, 0xbd, 0x04, 0xc0, 0x2e, 0xcb, 0xe9, 0x19, 0xf9,
	0x97, 0x73, 0x9e, 0x62, 0xad, 0x54, 0x2f, 0x35, 0x8c, 0x56, 0xdd, 0xf9, 0xbe, 0xb1, 0xb3, 0xae,
	0xeb, 0xad, 0xe2, 0x76, 0x95, 0x6c, 0x7e, 0x3e, 0x57, 0x9e, 0x4e, 0x5b, 0x8f, 0xc4, 0xe8, 0xdf,
	0xf4, 0xaf, 0xe5, 0x9f, 0x50, 0xd0, 0x98, 0x98, 0x1f, 0x33, 0xf4, 0xf8, 0xc7, 0xe1, 0x5f, 0x1b,
	0x6e, 0x1f, 0xfd, 0x2e, 0x9c, 0xa7, 0x53, 0x5b, 0xeb, 0xdc, 0xbe, 0xcc, 0x2d, 0x7d, 0x36, 0xb7,
	0xf4, 0xb7, 0xb9, 0xa5, 0x3f, 0x2d, 0x2c, 0x6d, 0xb6, 0xb0, 0xb4, 0xd7, 0x85, 0xa5, 0xdd, 0x9d,
	0x47, 0x89, 0x88, 0xc7, 0x81, 0x13, 0xf2, 0xcc, 0x55, 0x03, 0x4f, 0x52, 0x16, 0xe0, 0x5a, 0xb8,
	0x93, 0xf6, 0xe9, 0xfa, 0x09, 0x88, 0x69, 0x0e, 0xe8, 0xca, 0x9b, 0x5f, 0x7d, 0x07, 0xff, 0xa5,
	0x68, 0xbf, 0x07, 0x00, 0x00, 0xff, 0xff, 0x98, 0x14, 0xd2, 0xb8, 0x2d, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SQSIngesterClient is the client API for SQSIngester service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SQSIngesterClient interface {
	// ProcessBlock processes a block from the Osmosis node.
	ProcessBlock(ctx context.Context, in *ProcessBlockRequest, opts ...grpc.CallOption) (*ProcessBlockReply, error)
}

type sQSIngesterClient struct {
	cc grpc1.ClientConn
}

func NewSQSIngesterClient(cc grpc1.ClientConn) SQSIngesterClient {
	return &sQSIngesterClient{cc}
}

func (c *sQSIngesterClient) ProcessBlock(ctx context.Context, in *ProcessBlockRequest, opts ...grpc.CallOption) (*ProcessBlockReply, error) {
	out := new(ProcessBlockReply)
	err := c.cc.Invoke(ctx, "/osmosis.ingest.v1beta1.SQSIngester/ProcessBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SQSIngesterServer is the server API for SQSIngester service.
type SQSIngesterServer interface {
	// ProcessBlock processes a block from the Osmosis node.
	ProcessBlock(context.Context, *ProcessBlockRequest) (*ProcessBlockReply, error)
}

// UnimplementedSQSIngesterServer can be embedded to have forward compatible implementations.
type UnimplementedSQSIngesterServer struct {
}

func (*UnimplementedSQSIngesterServer) ProcessBlock(ctx context.Context, req *ProcessBlockRequest) (*ProcessBlockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessBlock not implemented")
}

func RegisterSQSIngesterServer(s grpc1.Server, srv SQSIngesterServer) {
	s.RegisterService(&_SQSIngester_serviceDesc, srv)
}

func _SQSIngester_ProcessBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SQSIngesterServer).ProcessBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.ingest.v1beta1.SQSIngester/ProcessBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SQSIngesterServer).ProcessBlock(ctx, req.(*ProcessBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SQSIngester_serviceDesc = grpc.ServiceDesc{
	ServiceName: "osmosis.ingest.v1beta1.SQSIngester",
	HandlerType: (*SQSIngesterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProcessBlock",
			Handler:    _SQSIngester_ProcessBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "osmosis/ingest/v1beta1/ingest.proto",
}

func (m *PoolData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TickModel) > 0 {
		i -= len(m.TickModel)
		copy(dAtA[i:], m.TickModel)
		i = encodeVarintIngest(dAtA, i, uint64(len(m.TickModel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SqsModel) > 0 {
		i -= len(m.SqsModel)
		copy(dAtA[i:], m.SqsModel)
		i = encodeVarintIngest(dAtA, i, uint64(len(m.SqsModel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainModel) > 0 {
		i -= len(m.ChainModel)
		copy(dAtA[i:], m.ChainModel)
		i = encodeVarintIngest(dAtA, i, uint64(len(m.ChainModel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessBlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessBlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessBlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIngest(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TakerFeesMap) > 0 {
		i -= len(m.TakerFeesMap)
		copy(dAtA[i:], m.TakerFeesMap)
		i = encodeVarintIngest(dAtA, i, uint64(len(m.TakerFeesMap)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockHeight != 0 {
		i = encodeVarintIngest(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessBlockReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessBlockReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessBlockReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintIngest(dAtA []byte, offset int, v uint64) int {
	offset -= sovIngest(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PoolData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainModel)
	if l > 0 {
		n += 1 + l + sovIngest(uint64(l))
	}
	l = len(m.SqsModel)
	if l > 0 {
		n += 1 + l + sovIngest(uint64(l))
	}
	l = len(m.TickModel)
	if l > 0 {
		n += 1 + l + sovIngest(uint64(l))
	}
	return n
}

func (m *ProcessBlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovIngest(uint64(m.BlockHeight))
	}
	l = len(m.TakerFeesMap)
	if l > 0 {
		n += 1 + l + sovIngest(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovIngest(uint64(l))
		}
	}
	return n
}

func (m *ProcessBlockReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovIngest(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIngest(x uint64) (n int) {
	return sovIngest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PoolData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainModel", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIngest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIngest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainModel = append(m.ChainModel[:0], dAtA[iNdEx:postIndex]...)
			if m.ChainModel == nil {
				m.ChainModel = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqsModel", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIngest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIngest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqsModel = append(m.SqsModel[:0], dAtA[iNdEx:postIndex]...)
			if m.SqsModel == nil {
				m.SqsModel = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickModel", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIngest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIngest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TickModel = append(m.TickModel[:0], dAtA[iNdEx:postIndex]...)
			if m.TickModel == nil {
				m.TickModel = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIngest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessBlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessBlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessBlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TakerFeesMap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIngest
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIngest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TakerFeesMap = append(m.TakerFeesMap[:0], dAtA[iNdEx:postIndex]...)
			if m.TakerFeesMap == nil {
				m.TakerFeesMap = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIngest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIngest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &PoolData{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIngest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIngest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessBlockReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIngest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessBlockReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessBlockReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipIngest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIngest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIngest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIngest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIngest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIngest
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIngest
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIngest
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIngest        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIngest          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIngest = fmt.Errorf("proto: unexpected end of group")
)
