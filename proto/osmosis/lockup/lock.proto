syntax = "proto3";
package osmosis.lockup;

import "gogoproto/gogo.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "cosmos/base/v1beta1/coin.proto";

option go_package = "github.com/osmosis-labs/osmosis/v7/x/lockup/types";

// PeriodLock is a single unit of lock by period defined by the x/lockup module.
// It's a record of locked coin at a specific time. It stores owner, duration,
// unlock time and the amount of coins locked. A state of a period lock is
// created upon lock creation, and deleted once the lock has been matured after
// the `duration` has passed since unbonding started.
message PeriodLock {
  // ID is the unique id of the lock.
  // The ID of the lock is decided upon lock creation, incrementing by 1 for
  // every lock.
  uint64 ID = 1;
  // Owner is the account address of the lock owner.
  // Only the owner can modify the state of the lock.
  string owner = 2 [ (gogoproto.moretags) = "yaml:\"owner\"" ];
  // Duration is the time needed for a lock to be matured after unlocking has
  // started.
  google.protobuf.Duration duration = 3 [
    (gogoproto.nullable) = false,
    (gogoproto.stdduration) = true,
    (gogoproto.jsontag) = "duration,omitempty",
    (gogoproto.moretags) = "yaml:\"duration\""
  ];
  // End Time refers to the time lock would be matured and deleted.
  // This value is first initialized when an unlock has started for the lock,
  // end time being block time + duration.
  google.protobuf.Timestamp end_time = 4 [
    (gogoproto.stdtime) = true,
    (gogoproto.nullable) = false,
    (gogoproto.moretags) = "yaml:\"end_time\""
  ];
  // Coins are the coins locked within the lock, kept in the module account.
  repeated cosmos.base.v1beta1.Coin coins = 5 [
    (gogoproto.nullable) = false,
    (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"
  ];
}

// LockQueryType defines the type of the lock query, query being
// either by duration or start time of the lock.
enum LockQueryType {
  option (gogoproto.goproto_enum_prefix) = false;

  ByDuration = 0;
  ByTime = 1;
}

// QueryCondition is a struct used for querying locks upon different conditions.
// Duration field and timestamp fields could be optional, depending on the
// LockQueryType.
message QueryCondition {
  // type of lock query, ByLockDuration | ByLockTime
  LockQueryType lock_query_type = 1;
  // What token denomination are we looking for lockups of
  string denom = 2;
  // Locks with longer duration than the specified duration would be queried.
  // Duration field should not be nil when lock query type is by duration.
  google.protobuf.Duration duration = 3 [
    (gogoproto.stdduration) = true,
    (gogoproto.nullable) = false,
    (gogoproto.moretags) = "yaml:\"duration\""
  ];
  // Locks started before specified timestamp would be queried.
  google.protobuf.Timestamp timestamp = 4 [
    (gogoproto.stdtime) = true,
    (gogoproto.nullable) = false,
    (gogoproto.moretags) = "yaml:\"timestamp\""
  ];
}

// SyntheticLock is a single unit of synthetic lockup that is created upon every
// superfluid delegation.
message SyntheticLock {
  // Underlying Lock ID is the underlying native lock's id for this synthetic
  // lockup. A synthetic lock MUST have an underlying lock.
  uint64 underlying_lock_id = 1;
  // Synth Denom is the synthetic denom of which is a combination of
  // gamm share + bonding status + validator address
  string synth_denom = 2;
  // used for unbonding synthetic lockups, for active synthetic lockups, this
  // value is set to uninitialized value
  google.protobuf.Timestamp end_time = 3 [
    (gogoproto.stdtime) = true,
    (gogoproto.nullable) = false,
    (gogoproto.moretags) = "yaml:\"end_time\""
  ];
  // Duration is the duration which is needed for a synthetic lock to be mature
  // at the point of unbonding has started.
  google.protobuf.Duration duration = 4 [
    (gogoproto.nullable) = false,
    (gogoproto.stdduration) = true,
    (gogoproto.jsontag) = "duration,omitempty",
    (gogoproto.moretags) = "yaml:\"duration\""
  ];
}
