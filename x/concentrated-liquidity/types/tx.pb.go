// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osmosis/concentrated-liquidity/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ===================== MsgCreatePosition
type MsgCreatePosition struct {
	PoolId    uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty" yaml:"pool_id"`
	Sender    string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	LowerTick int64  `protobuf:"varint,3,opt,name=lower_tick,json=lowerTick,proto3" json:"lower_tick,omitempty" yaml:"lower_tick"`
	UpperTick int64  `protobuf:"varint,4,opt,name=upper_tick,json=upperTick,proto3" json:"upper_tick,omitempty" yaml:"upper_tick"`
	// tokens_provided is the amount of tokens provided for the position.
	// It must at a minimum be of length 1 (for a single sided position)
	// and at a maximum be of length 2 (for a position that straddles the current
	// tick).
	TokensProvided  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=tokens_provided,json=tokensProvided,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"tokens_provided"`
	TokenMinAmount0 github_com_cosmos_cosmos_sdk_types.Int   `protobuf:"bytes,6,opt,name=token_min_amount0,json=tokenMinAmount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"token_min_amount0" yaml:"token_min_amount0"`
	TokenMinAmount1 github_com_cosmos_cosmos_sdk_types.Int   `protobuf:"bytes,7,opt,name=token_min_amount1,json=tokenMinAmount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"token_min_amount1" yaml:"token_min_amount1"`
}

func (m *MsgCreatePosition) Reset()         { *m = MsgCreatePosition{} }
func (m *MsgCreatePosition) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePosition) ProtoMessage()    {}
func (*MsgCreatePosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{0}
}
func (m *MsgCreatePosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePosition.Merge(m, src)
}
func (m *MsgCreatePosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePosition proto.InternalMessageInfo

func (m *MsgCreatePosition) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *MsgCreatePosition) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreatePosition) GetLowerTick() int64 {
	if m != nil {
		return m.LowerTick
	}
	return 0
}

func (m *MsgCreatePosition) GetUpperTick() int64 {
	if m != nil {
		return m.UpperTick
	}
	return 0
}

func (m *MsgCreatePosition) GetTokensProvided() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TokensProvided
	}
	return nil
}

type MsgCreatePositionResponse struct {
	PositionId       uint64                                 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty" yaml:"position_id"`
	Amount0          github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=amount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount0" yaml:"amount0"`
	Amount1          github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount1" yaml:"amount1"`
	LiquidityCreated github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=liquidity_created,json=liquidityCreated,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidity_created" yaml:"liquidity_created"`
	// the lower and upper tick are in the response because there are
	// instances in which multiple ticks represent the same price, so
	// we may move their provided tick to the canonical tick that represents
	// the same price.
	LowerTick int64 `protobuf:"varint,6,opt,name=lower_tick,json=lowerTick,proto3" json:"lower_tick,omitempty" yaml:"lower_tick"`
	UpperTick int64 `protobuf:"varint,7,opt,name=upper_tick,json=upperTick,proto3" json:"upper_tick,omitempty" yaml:"upper_tick"`
}

func (m *MsgCreatePositionResponse) Reset()         { *m = MsgCreatePositionResponse{} }
func (m *MsgCreatePositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePositionResponse) ProtoMessage()    {}
func (*MsgCreatePositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{1}
}
func (m *MsgCreatePositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePositionResponse.Merge(m, src)
}
func (m *MsgCreatePositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePositionResponse proto.InternalMessageInfo

func (m *MsgCreatePositionResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgCreatePositionResponse) GetLowerTick() int64 {
	if m != nil {
		return m.LowerTick
	}
	return 0
}

func (m *MsgCreatePositionResponse) GetUpperTick() int64 {
	if m != nil {
		return m.UpperTick
	}
	return 0
}

// ===================== MsgAddToPosition
type MsgAddToPosition struct {
	PositionId uint64 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty" yaml:"position_id"`
	Sender     string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	// amount0 represents the amount of token0 willing to put in.
	Amount0 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount0" yaml:"amount_0"`
	// amount1 represents the amount of token1 willing to put in.
	Amount1 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=amount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount1" yaml:"amount_1"`
	// token_min_amount0 represents the minimum amount of token0 desired from the
	// new position being created. Note that this field indicates the min amount0
	// corresponding to the liquidity that is being added, not the total
	// liquidity of the position.
	TokenMinAmount0 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,5,opt,name=token_min_amount0,json=tokenMinAmount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"token_min_amount0" yaml:"token_min_amount0"`
	// token_min_amount1 represents the minimum amount of token1 desired from the
	// new position being created. Note that this field indicates the min amount1
	// corresponding to the liquidity that is being added, not the total
	// liquidity of the position.
	TokenMinAmount1 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=token_min_amount1,json=tokenMinAmount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"token_min_amount1" yaml:"token_min_amount1"`
}

func (m *MsgAddToPosition) Reset()         { *m = MsgAddToPosition{} }
func (m *MsgAddToPosition) String() string { return proto.CompactTextString(m) }
func (*MsgAddToPosition) ProtoMessage()    {}
func (*MsgAddToPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{2}
}
func (m *MsgAddToPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToPosition.Merge(m, src)
}
func (m *MsgAddToPosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToPosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToPosition proto.InternalMessageInfo

func (m *MsgAddToPosition) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgAddToPosition) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgAddToPositionResponse struct {
	PositionId uint64                                 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty" yaml:"position_id"`
	Amount0    github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=amount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount0" yaml:"amount0"`
	Amount1    github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount1" yaml:"amount1"`
}

func (m *MsgAddToPositionResponse) Reset()         { *m = MsgAddToPositionResponse{} }
func (m *MsgAddToPositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddToPositionResponse) ProtoMessage()    {}
func (*MsgAddToPositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{3}
}
func (m *MsgAddToPositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddToPositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddToPositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddToPositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddToPositionResponse.Merge(m, src)
}
func (m *MsgAddToPositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddToPositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddToPositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddToPositionResponse proto.InternalMessageInfo

func (m *MsgAddToPositionResponse) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

// ===================== MsgWithdrawPosition
type MsgWithdrawPosition struct {
	PositionId      uint64                                 `protobuf:"varint,1,opt,name=position_id,json=positionId,proto3" json:"position_id,omitempty" yaml:"position_id"`
	Sender          string                                 `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	LiquidityAmount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=liquidity_amount,json=liquidityAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"liquidity_amount" yaml:"liquidity_amount"`
}

func (m *MsgWithdrawPosition) Reset()         { *m = MsgWithdrawPosition{} }
func (m *MsgWithdrawPosition) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawPosition) ProtoMessage()    {}
func (*MsgWithdrawPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{4}
}
func (m *MsgWithdrawPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawPosition.Merge(m, src)
}
func (m *MsgWithdrawPosition) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawPosition.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawPosition proto.InternalMessageInfo

func (m *MsgWithdrawPosition) GetPositionId() uint64 {
	if m != nil {
		return m.PositionId
	}
	return 0
}

func (m *MsgWithdrawPosition) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgWithdrawPositionResponse struct {
	Amount0 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=amount0,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount0" yaml:"amount0"`
	Amount1 github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=amount1,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount1" yaml:"amount1"`
}

func (m *MsgWithdrawPositionResponse) Reset()         { *m = MsgWithdrawPositionResponse{} }
func (m *MsgWithdrawPositionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawPositionResponse) ProtoMessage()    {}
func (*MsgWithdrawPositionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{5}
}
func (m *MsgWithdrawPositionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawPositionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawPositionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawPositionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawPositionResponse.Merge(m, src)
}
func (m *MsgWithdrawPositionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawPositionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawPositionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawPositionResponse proto.InternalMessageInfo

// ===================== MsgCollectSpreadRewards
type MsgCollectSpreadRewards struct {
	PositionIds []uint64 `protobuf:"varint,1,rep,packed,name=position_ids,json=positionIds,proto3" json:"position_ids,omitempty" yaml:"position_ids"`
	Sender      string   `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
}

func (m *MsgCollectSpreadRewards) Reset()         { *m = MsgCollectSpreadRewards{} }
func (m *MsgCollectSpreadRewards) String() string { return proto.CompactTextString(m) }
func (*MsgCollectSpreadRewards) ProtoMessage()    {}
func (*MsgCollectSpreadRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{6}
}
func (m *MsgCollectSpreadRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCollectSpreadRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCollectSpreadRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCollectSpreadRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCollectSpreadRewards.Merge(m, src)
}
func (m *MsgCollectSpreadRewards) XXX_Size() int {
	return m.Size()
}
func (m *MsgCollectSpreadRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCollectSpreadRewards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCollectSpreadRewards proto.InternalMessageInfo

func (m *MsgCollectSpreadRewards) GetPositionIds() []uint64 {
	if m != nil {
		return m.PositionIds
	}
	return nil
}

func (m *MsgCollectSpreadRewards) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgCollectSpreadRewardsResponse struct {
	CollectedSpreadRewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=collected_spread_rewards,json=collectedSpreadRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"collected_spread_rewards" yaml:"collected_spread_rewards"`
}

func (m *MsgCollectSpreadRewardsResponse) Reset()         { *m = MsgCollectSpreadRewardsResponse{} }
func (m *MsgCollectSpreadRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCollectSpreadRewardsResponse) ProtoMessage()    {}
func (*MsgCollectSpreadRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{7}
}
func (m *MsgCollectSpreadRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCollectSpreadRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCollectSpreadRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCollectSpreadRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCollectSpreadRewardsResponse.Merge(m, src)
}
func (m *MsgCollectSpreadRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCollectSpreadRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCollectSpreadRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCollectSpreadRewardsResponse proto.InternalMessageInfo

func (m *MsgCollectSpreadRewardsResponse) GetCollectedSpreadRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CollectedSpreadRewards
	}
	return nil
}

// ===================== MsgCollectIncentives
type MsgCollectIncentives struct {
	PositionIds []uint64 `protobuf:"varint,1,rep,packed,name=position_ids,json=positionIds,proto3" json:"position_ids,omitempty" yaml:"position_ids"`
	Sender      string   `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
}

func (m *MsgCollectIncentives) Reset()         { *m = MsgCollectIncentives{} }
func (m *MsgCollectIncentives) String() string { return proto.CompactTextString(m) }
func (*MsgCollectIncentives) ProtoMessage()    {}
func (*MsgCollectIncentives) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{8}
}
func (m *MsgCollectIncentives) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCollectIncentives) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCollectIncentives.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCollectIncentives) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCollectIncentives.Merge(m, src)
}
func (m *MsgCollectIncentives) XXX_Size() int {
	return m.Size()
}
func (m *MsgCollectIncentives) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCollectIncentives.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCollectIncentives proto.InternalMessageInfo

func (m *MsgCollectIncentives) GetPositionIds() []uint64 {
	if m != nil {
		return m.PositionIds
	}
	return nil
}

func (m *MsgCollectIncentives) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgCollectIncentivesResponse struct {
	CollectedIncentives github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=collected_incentives,json=collectedIncentives,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"collected_incentives" yaml:"collected_incentives"`
	ForfeitedIncentives github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=forfeited_incentives,json=forfeitedIncentives,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"forfeited_incentives" yaml:"forfeited_incentives"`
}

func (m *MsgCollectIncentivesResponse) Reset()         { *m = MsgCollectIncentivesResponse{} }
func (m *MsgCollectIncentivesResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCollectIncentivesResponse) ProtoMessage()    {}
func (*MsgCollectIncentivesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{9}
}
func (m *MsgCollectIncentivesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCollectIncentivesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCollectIncentivesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCollectIncentivesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCollectIncentivesResponse.Merge(m, src)
}
func (m *MsgCollectIncentivesResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCollectIncentivesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCollectIncentivesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCollectIncentivesResponse proto.InternalMessageInfo

func (m *MsgCollectIncentivesResponse) GetCollectedIncentives() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CollectedIncentives
	}
	return nil
}

func (m *MsgCollectIncentivesResponse) GetForfeitedIncentives() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ForfeitedIncentives
	}
	return nil
}

// ===================== MsgFungifyChargedPositions
type MsgFungifyChargedPositions struct {
	PositionIds []uint64 `protobuf:"varint,1,rep,packed,name=position_ids,json=positionIds,proto3" json:"position_ids,omitempty" yaml:"position_ids"`
	Sender      string   `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
}

func (m *MsgFungifyChargedPositions) Reset()         { *m = MsgFungifyChargedPositions{} }
func (m *MsgFungifyChargedPositions) String() string { return proto.CompactTextString(m) }
func (*MsgFungifyChargedPositions) ProtoMessage()    {}
func (*MsgFungifyChargedPositions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{10}
}
func (m *MsgFungifyChargedPositions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFungifyChargedPositions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFungifyChargedPositions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFungifyChargedPositions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFungifyChargedPositions.Merge(m, src)
}
func (m *MsgFungifyChargedPositions) XXX_Size() int {
	return m.Size()
}
func (m *MsgFungifyChargedPositions) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFungifyChargedPositions.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFungifyChargedPositions proto.InternalMessageInfo

func (m *MsgFungifyChargedPositions) GetPositionIds() []uint64 {
	if m != nil {
		return m.PositionIds
	}
	return nil
}

func (m *MsgFungifyChargedPositions) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

type MsgFungifyChargedPositionsResponse struct {
	NewPositionId uint64 `protobuf:"varint,1,opt,name=new_position_id,json=newPositionId,proto3" json:"new_position_id,omitempty" yaml:"new_position_id"`
}

func (m *MsgFungifyChargedPositionsResponse) Reset()         { *m = MsgFungifyChargedPositionsResponse{} }
func (m *MsgFungifyChargedPositionsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFungifyChargedPositionsResponse) ProtoMessage()    {}
func (*MsgFungifyChargedPositionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f1fff802923d7db, []int{11}
}
func (m *MsgFungifyChargedPositionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFungifyChargedPositionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFungifyChargedPositionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFungifyChargedPositionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFungifyChargedPositionsResponse.Merge(m, src)
}
func (m *MsgFungifyChargedPositionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFungifyChargedPositionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFungifyChargedPositionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFungifyChargedPositionsResponse proto.InternalMessageInfo

func (m *MsgFungifyChargedPositionsResponse) GetNewPositionId() uint64 {
	if m != nil {
		return m.NewPositionId
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgCreatePosition)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCreatePosition")
	proto.RegisterType((*MsgCreatePositionResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCreatePositionResponse")
	proto.RegisterType((*MsgAddToPosition)(nil), "osmosis.concentratedliquidity.v1beta1.MsgAddToPosition")
	proto.RegisterType((*MsgAddToPositionResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgAddToPositionResponse")
	proto.RegisterType((*MsgWithdrawPosition)(nil), "osmosis.concentratedliquidity.v1beta1.MsgWithdrawPosition")
	proto.RegisterType((*MsgWithdrawPositionResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgWithdrawPositionResponse")
	proto.RegisterType((*MsgCollectSpreadRewards)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewards")
	proto.RegisterType((*MsgCollectSpreadRewardsResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCollectSpreadRewardsResponse")
	proto.RegisterType((*MsgCollectIncentives)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCollectIncentives")
	proto.RegisterType((*MsgCollectIncentivesResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgCollectIncentivesResponse")
	proto.RegisterType((*MsgFungifyChargedPositions)(nil), "osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositions")
	proto.RegisterType((*MsgFungifyChargedPositionsResponse)(nil), "osmosis.concentratedliquidity.v1beta1.MsgFungifyChargedPositionsResponse")
}

func init() {
	proto.RegisterFile("osmosis/concentrated-liquidity/tx.proto", fileDescriptor_1f1fff802923d7db)
}

var fileDescriptor_1f1fff802923d7db = []byte{
	// 1063 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xee, 0x34, 0x69, 0xaa, 0x4e, 0xe9, 0x8f, 0xb8, 0xa5, 0xf5, 0x66, 0x51, 0x5c, 0x8d, 0x04,
	0x04, 0xa1, 0xc6, 0x9b, 0x05, 0x01, 0x2a, 0x12, 0x6c, 0x53, 0xb4, 0x52, 0x90, 0x22, 0x56, 0xde,
	0x95, 0x90, 0x76, 0x91, 0x2c, 0xc7, 0x9e, 0xba, 0xa3, 0x26, 0x1e, 0xe3, 0x99, 0xb4, 0xdb, 0x03,
	0x12, 0x12, 0x27, 0x04, 0x07, 0x84, 0xc4, 0x11, 0xc4, 0x11, 0xf1, 0x3f, 0x70, 0xdf, 0x03, 0x87,
	0xbd, 0x20, 0x21, 0x0e, 0x06, 0xb5, 0x77, 0x10, 0xf9, 0x0b, 0x90, 0x7f, 0x8d, 0xb3, 0x4e, 0x0a,
	0x71, 0xda, 0x2d, 0x87, 0x3d, 0x25, 0x33, 0xf3, 0xbe, 0xef, 0xbd, 0xf9, 0xde, 0x9b, 0xe7, 0xb1,
	0xe1, 0xcb, 0x94, 0xf5, 0x28, 0x23, 0x4c, 0x35, 0xa9, 0x63, 0x62, 0x87, 0x7b, 0x06, 0xc7, 0xd6,
	0x76, 0x97, 0x7c, 0xdc, 0x27, 0x16, 0xe1, 0x27, 0x2a, 0x7f, 0x58, 0x77, 0x3d, 0xca, 0xa9, 0xf4,
	0x62, 0x6c, 0x58, 0x1f, 0x36, 0x14, 0x76, 0xf5, 0xa3, 0x46, 0x07, 0x73, 0xa3, 0x51, 0x59, 0xb7,
	0xa9, 0x4d, 0x43, 0x84, 0x1a, 0xfc, 0x8b, 0xc0, 0x15, 0xc5, 0xa6, 0xd4, 0xee, 0x62, 0x35, 0x1c,
	0x75, 0xfa, 0xfb, 0x2a, 0x27, 0x3d, 0xcc, 0xb8, 0xd1, 0x73, 0x63, 0x83, 0x6a, 0xd6, 0xc0, 0xea,
	0x7b, 0x06, 0x27, 0xd4, 0x49, 0xd6, 0xcd, 0xd0, 0xbd, 0xda, 0x31, 0x18, 0x56, 0x63, 0x5f, 0xaa,
	0x49, 0x49, 0xbc, 0x8e, 0x7e, 0x2a, 0xc2, 0x72, 0x9b, 0xd9, 0x7b, 0x1e, 0x36, 0x38, 0xbe, 0x43,
	0x19, 0x09, 0xb0, 0xd2, 0xab, 0x70, 0xde, 0xa5, 0xb4, 0xab, 0x13, 0x4b, 0x06, 0x5b, 0xa0, 0x56,
	0x6c, 0x4a, 0x03, 0x5f, 0x59, 0x3e, 0x31, 0x7a, 0xdd, 0x1d, 0x14, 0x2f, 0x20, 0xad, 0x14, 0xfc,
	0x6b, 0x59, 0xd2, 0x2b, 0xb0, 0xc4, 0xb0, 0x63, 0x61, 0x4f, 0x9e, 0xdd, 0x02, 0xb5, 0x85, 0x66,
	0x79, 0xe0, 0x2b, 0x4b, 0x91, 0x6d, 0x34, 0x8f, 0xb4, 0xd8, 0x40, 0x7a, 0x1d, 0xc2, 0x2e, 0x3d,
	0xc6, 0x9e, 0xce, 0x89, 0x79, 0x28, 0x17, 0xb6, 0x40, 0xad, 0xd0, 0x7c, 0x7e, 0xe0, 0x2b, 0xe5,
	0xc8, 0x3c, 0x5d, 0x43, 0xda, 0x42, 0x38, 0xb8, 0x47, 0xcc, 0xc3, 0x00, 0xd5, 0x77, 0xdd, 0x04,
	0x55, 0xcc, 0xa2, 0xd2, 0x35, 0xa4, 0x2d, 0x84, 0x83, 0x10, 0xc5, 0xe1, 0x0a, 0xa7, 0x87, 0xd8,
	0x61, 0xba, 0xeb, 0xd1, 0x23, 0x62, 0x61, 0x4b, 0x9e, 0xdb, 0x2a, 0xd4, 0x16, 0x6f, 0x5e, 0xab,
	0x47, 0x9a, 0xd4, 0x03, 0x4d, 0x12, 0xfd, 0xeb, 0x7b, 0x94, 0x38, 0xcd, 0x1b, 0x8f, 0x7c, 0x65,
	0xe6, 0xc7, 0xdf, 0x95, 0x9a, 0x4d, 0xf8, 0x41, 0xbf, 0x53, 0x37, 0x69, 0x4f, 0x8d, 0x05, 0x8c,
	0x7e, 0xb6, 0x99, 0x75, 0xa8, 0xf2, 0x13, 0x17, 0xb3, 0x10, 0xc0, 0xb4, 0xe5, 0xc8, 0xc7, 0x9d,
	0xd8, 0x85, 0x74, 0x04, 0xcb, 0xe1, 0x8c, 0xde, 0x23, 0x8e, 0x6e, 0xf4, 0x68, 0xdf, 0xe1, 0x37,
	0xe4, 0x52, 0xa8, 0xcb, 0xfb, 0x01, 0xf9, 0x6f, 0xbe, 0xf2, 0xd2, 0x04, 0xe4, 0x2d, 0x87, 0x0f,
	0x7c, 0x45, 0x8e, 0x36, 0x38, 0x42, 0x88, 0xb4, 0x68, 0x6b, 0x6d, 0xe2, 0xec, 0x46, 0x33, 0xe3,
	0xfc, 0x36, 0xe4, 0xf9, 0xcb, 0xf5, 0xdb, 0x18, 0xf1, 0xdb, 0x40, 0x7f, 0x17, 0xe0, 0xb5, 0x91,
	0xfa, 0xd1, 0x30, 0x73, 0xa9, 0xc3, 0xb0, 0xf4, 0x26, 0x5c, 0x74, 0xe3, 0xb9, 0xb4, 0x96, 0x36,
	0x06, 0xbe, 0x22, 0x25, 0xb5, 0x24, 0x16, 0x91, 0x06, 0x93, 0x51, 0xcb, 0x92, 0xee, 0xc3, 0xf9,
	0x44, 0xbc, 0xa8, 0xa8, 0x6e, 0xe5, 0xde, 0x44, 0x5c, 0xae, 0x42, 0xb2, 0x84, 0x30, 0xe5, 0x6e,
	0x84, 0x15, 0x78, 0x61, 0xee, 0x86, 0xe0, 0x6e, 0x48, 0xc7, 0xb0, 0x2c, 0x8e, 0xb6, 0x6e, 0x86,
	0xa2, 0x04, 0x65, 0x97, 0x37, 0x0d, 0xef, 0x61, 0x33, 0x4d, 0xc3, 0x08, 0x21, 0xd2, 0x56, 0xc5,
	0x5c, 0x24, 0xbc, 0x95, 0x39, 0x59, 0xa5, 0xa9, 0x4e, 0xd6, 0xfc, 0x64, 0x27, 0x0b, 0x7d, 0x5f,
	0x84, 0xab, 0x6d, 0x66, 0xef, 0x5a, 0xd6, 0x3d, 0x2a, 0x5a, 0xc6, 0xd4, 0xa9, 0xce, 0xd1, 0x3e,
	0x1e, 0xa4, 0x55, 0x11, 0x65, 0x6e, 0x37, 0x77, 0xe6, 0x56, 0x86, 0x33, 0xa7, 0x0f, 0x97, 0xc5,
	0x83, 0xb4, 0x2c, 0x8a, 0x97, 0x42, 0x3e, 0x5c, 0x17, 0x63, 0xdb, 0xc2, 0xdc, 0xff, 0xd4, 0x16,
	0x4a, 0x4f, 0xbf, 0x2d, 0x7c, 0x31, 0x0b, 0xe5, 0x6c, 0x89, 0x3c, 0xb3, 0x5d, 0x01, 0xfd, 0x05,
	0xe0, 0x5a, 0x9b, 0xd9, 0x1f, 0x12, 0x7e, 0x60, 0x79, 0xc6, 0xf1, 0x95, 0x9e, 0x19, 0x0e, 0xd3,
	0x66, 0x11, 0x27, 0x2c, 0xde, 0x60, 0x2b, 0x77, 0x43, 0xda, 0xcc, 0x36, 0xa4, 0x88, 0x0f, 0x69,
	0x2b, 0x62, 0x2a, 0x2a, 0x00, 0xf4, 0x0b, 0x80, 0xd7, 0xc7, 0xec, 0x58, 0x94, 0xc0, 0x50, 0x26,
	0xc1, 0x53, 0xcc, 0xe4, 0xec, 0x65, 0x67, 0xf2, 0x53, 0x00, 0x37, 0x83, 0xc7, 0x1d, 0xed, 0x76,
	0xb1, 0xc9, 0xef, 0xba, 0x1e, 0x36, 0x2c, 0x0d, 0x1f, 0x1b, 0x9e, 0xc5, 0xa4, 0x1d, 0xf8, 0xdc,
	0x50, 0xc2, 0x98, 0x0c, 0xb6, 0x0a, 0xb5, 0x62, 0x73, 0x73, 0xe0, 0x2b, 0x6b, 0x23, 0xe9, 0x64,
	0x48, 0x5b, 0x4c, 0xf3, 0xc9, 0x72, 0x24, 0x14, 0xfd, 0x0c, 0xa0, 0x72, 0x4e, 0x08, 0x42, 0xde,
	0x1f, 0x00, 0x94, 0xcd, 0xc8, 0x00, 0x5b, 0x3a, 0x0b, 0x6d, 0x74, 0x2f, 0x32, 0x0a, 0xe3, 0xfa,
	0xd7, 0x5b, 0xd0, 0xdd, 0x40, 0xaf, 0x81, 0xaf, 0x28, 0x51, 0x00, 0xe7, 0x11, 0xa1, 0x5c, 0x17,
	0xa5, 0x0d, 0x41, 0xf3, 0x44, 0xc8, 0xe8, 0x13, 0xb8, 0x9e, 0xee, 0xa6, 0x15, 0xde, 0x90, 0xc9,
	0x11, 0xbe, 0x32, 0x35, 0xfd, 0x59, 0xf8, 0xc2, 0x38, 0xff, 0x42, 0xca, 0x6f, 0x01, 0x5c, 0x4f,
	0x15, 0x20, 0xc2, 0xe0, 0xbf, 0x65, 0xfc, 0x20, 0x96, 0xf1, 0x7a, 0x56, 0xc6, 0x94, 0x24, 0x9f,
	0x84, 0x6b, 0x82, 0x62, 0x48, 0xa7, 0x20, 0xbe, 0x7d, 0xea, 0xed, 0x63, 0x92, 0x89, 0x6f, 0x36,
	0x67, 0x7c, 0xe3, 0x48, 0x72, 0xc6, 0x27, 0x28, 0xd2, 0xf8, 0xd0, 0x67, 0x00, 0x56, 0xda, 0xcc,
	0xbe, 0xdd, 0x77, 0x6c, 0xb2, 0x7f, 0xb2, 0x77, 0x60, 0x78, 0x36, 0xb6, 0x92, 0x7e, 0x70, 0x65,
	0x69, 0x3e, 0x80, 0xe8, 0xfc, 0x20, 0x44, 0xae, 0x9b, 0x70, 0xc5, 0xc1, 0xc7, 0xfa, 0x68, 0x4f,
	0xae, 0x0c, 0x7c, 0x65, 0x23, 0x62, 0xce, 0x18, 0x20, 0x6d, 0xc9, 0xc1, 0xa2, 0xbf, 0xb5, 0xac,
	0x9b, 0x7f, 0xce, 0xc1, 0x42, 0x9b, 0xd9, 0xd2, 0x97, 0x00, 0x2e, 0x67, 0xde, 0xaa, 0xde, 0xaa,
	0x4f, 0xf4, 0x2a, 0x58, 0x1f, 0xb9, 0x4f, 0x57, 0x6e, 0x4d, 0x8b, 0x14, 0x5b, 0xfb, 0x1a, 0xc0,
	0xd5, 0x91, 0xe7, 0xcf, 0xce, 0xe4, 0xb4, 0x59, 0x6c, 0xa5, 0x39, 0x3d, 0x56, 0x04, 0xf5, 0x39,
	0x80, 0x4b, 0x99, 0x5b, 0xe4, 0xe4, 0xac, 0x4f, 0x00, 0x2b, 0xef, 0x4e, 0x09, 0x14, 0xb1, 0x7c,
	0x07, 0xe0, 0xfa, 0xd8, 0xb6, 0xfe, 0x4e, 0x0e, 0xed, 0xc7, 0xe0, 0x2b, 0xb7, 0x2f, 0x86, 0x17,
	0x01, 0x7e, 0x03, 0x60, 0x79, 0xb4, 0x4d, 0xbe, 0x9d, 0x9b, 0x3d, 0x05, 0x57, 0xf6, 0x2e, 0x00,
	0x4e, 0xe2, 0x6a, 0x7e, 0xf4, 0xe8, 0xb4, 0x0a, 0x1e, 0x9f, 0x56, 0xc1, 0x1f, 0xa7, 0x55, 0xf0,
	0xd5, 0x59, 0x75, 0xe6, 0xf1, 0x59, 0x75, 0xe6, 0xd7, 0xb3, 0xea, 0xcc, 0xfd, 0xe6, 0x50, 0xe7,
	0x88, 0x1d, 0x6d, 0x77, 0x8d, 0x0e, 0x4b, 0x06, 0xea, 0x51, 0xe3, 0x0d, 0xf5, 0xe1, 0xb9, 0x1f,
	0x50, 0x82, 0xce, 0xd2, 0x29, 0x85, 0x9f, 0x29, 0x5e, 0xfb, 0x27, 0x00, 0x00, 0xff, 0xff, 0xb7,
	0x80, 0xf6, 0x45, 0x6f, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	CreatePosition(ctx context.Context, in *MsgCreatePosition, opts ...grpc.CallOption) (*MsgCreatePositionResponse, error)
	WithdrawPosition(ctx context.Context, in *MsgWithdrawPosition, opts ...grpc.CallOption) (*MsgWithdrawPositionResponse, error)
	// AddToPosition attempts to add amount0 and amount1 to a position
	// with the given position id.
	// To maintain backwards-compatibility with future implementations of
	// charging, this function deletes the old position and creates a new one with
	// the resulting amount after addition.
	AddToPosition(ctx context.Context, in *MsgAddToPosition, opts ...grpc.CallOption) (*MsgAddToPositionResponse, error)
	CollectSpreadRewards(ctx context.Context, in *MsgCollectSpreadRewards, opts ...grpc.CallOption) (*MsgCollectSpreadRewardsResponse, error)
	CollectIncentives(ctx context.Context, in *MsgCollectIncentives, opts ...grpc.CallOption) (*MsgCollectIncentivesResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreatePosition(ctx context.Context, in *MsgCreatePosition, opts ...grpc.CallOption) (*MsgCreatePositionResponse, error) {
	out := new(MsgCreatePositionResponse)
	err := c.cc.Invoke(ctx, "/osmosis.concentratedliquidity.v1beta1.Msg/CreatePosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) WithdrawPosition(ctx context.Context, in *MsgWithdrawPosition, opts ...grpc.CallOption) (*MsgWithdrawPositionResponse, error) {
	out := new(MsgWithdrawPositionResponse)
	err := c.cc.Invoke(ctx, "/osmosis.concentratedliquidity.v1beta1.Msg/WithdrawPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddToPosition(ctx context.Context, in *MsgAddToPosition, opts ...grpc.CallOption) (*MsgAddToPositionResponse, error) {
	out := new(MsgAddToPositionResponse)
	err := c.cc.Invoke(ctx, "/osmosis.concentratedliquidity.v1beta1.Msg/AddToPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CollectSpreadRewards(ctx context.Context, in *MsgCollectSpreadRewards, opts ...grpc.CallOption) (*MsgCollectSpreadRewardsResponse, error) {
	out := new(MsgCollectSpreadRewardsResponse)
	err := c.cc.Invoke(ctx, "/osmosis.concentratedliquidity.v1beta1.Msg/CollectSpreadRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CollectIncentives(ctx context.Context, in *MsgCollectIncentives, opts ...grpc.CallOption) (*MsgCollectIncentivesResponse, error) {
	out := new(MsgCollectIncentivesResponse)
	err := c.cc.Invoke(ctx, "/osmosis.concentratedliquidity.v1beta1.Msg/CollectIncentives", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	CreatePosition(context.Context, *MsgCreatePosition) (*MsgCreatePositionResponse, error)
	WithdrawPosition(context.Context, *MsgWithdrawPosition) (*MsgWithdrawPositionResponse, error)
	// AddToPosition attempts to add amount0 and amount1 to a position
	// with the given position id.
	// To maintain backwards-compatibility with future implementations of
	// charging, this function deletes the old position and creates a new one with
	// the resulting amount after addition.
	AddToPosition(context.Context, *MsgAddToPosition) (*MsgAddToPositionResponse, error)
	CollectSpreadRewards(context.Context, *MsgCollectSpreadRewards) (*MsgCollectSpreadRewardsResponse, error)
	CollectIncentives(context.Context, *MsgCollectIncentives) (*MsgCollectIncentivesResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreatePosition(ctx context.Context, req *MsgCreatePosition) (*MsgCreatePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePosition not implemented")
}
func (*UnimplementedMsgServer) WithdrawPosition(ctx context.Context, req *MsgWithdrawPosition) (*MsgWithdrawPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawPosition not implemented")
}
func (*UnimplementedMsgServer) AddToPosition(ctx context.Context, req *MsgAddToPosition) (*MsgAddToPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToPosition not implemented")
}
func (*UnimplementedMsgServer) CollectSpreadRewards(ctx context.Context, req *MsgCollectSpreadRewards) (*MsgCollectSpreadRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectSpreadRewards not implemented")
}
func (*UnimplementedMsgServer) CollectIncentives(ctx context.Context, req *MsgCollectIncentives) (*MsgCollectIncentivesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CollectIncentives not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreatePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.concentratedliquidity.v1beta1.Msg/CreatePosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreatePosition(ctx, req.(*MsgCreatePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_WithdrawPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdrawPosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).WithdrawPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.concentratedliquidity.v1beta1.Msg/WithdrawPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).WithdrawPosition(ctx, req.(*MsgWithdrawPosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddToPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddToPosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddToPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.concentratedliquidity.v1beta1.Msg/AddToPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddToPosition(ctx, req.(*MsgAddToPosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CollectSpreadRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCollectSpreadRewards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CollectSpreadRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.concentratedliquidity.v1beta1.Msg/CollectSpreadRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CollectSpreadRewards(ctx, req.(*MsgCollectSpreadRewards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CollectIncentives_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCollectIncentives)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CollectIncentives(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/osmosis.concentratedliquidity.v1beta1.Msg/CollectIncentives",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CollectIncentives(ctx, req.(*MsgCollectIncentives))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "osmosis.concentratedliquidity.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePosition",
			Handler:    _Msg_CreatePosition_Handler,
		},
		{
			MethodName: "WithdrawPosition",
			Handler:    _Msg_WithdrawPosition_Handler,
		},
		{
			MethodName: "AddToPosition",
			Handler:    _Msg_AddToPosition_Handler,
		},
		{
			MethodName: "CollectSpreadRewards",
			Handler:    _Msg_CollectSpreadRewards_Handler,
		},
		{
			MethodName: "CollectIncentives",
			Handler:    _Msg_CollectIncentives_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "osmosis/concentrated-liquidity/tx.proto",
}

func (m *MsgCreatePosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TokenMinAmount1.Size()
		i -= size
		if _, err := m.TokenMinAmount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TokenMinAmount0.Size()
		i -= size
		if _, err := m.TokenMinAmount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.TokensProvided) > 0 {
		for iNdEx := len(m.TokensProvided) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TokensProvided[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UpperTick != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.UpperTick))
		i--
		dAtA[i] = 0x20
	}
	if m.LowerTick != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LowerTick))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreatePositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpperTick != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.UpperTick))
		i--
		dAtA[i] = 0x38
	}
	if m.LowerTick != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LowerTick))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.LiquidityCreated.Size()
		i -= size
		if _, err := m.LiquidityCreated.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Amount1.Size()
		i -= size
		if _, err := m.Amount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount0.Size()
		i -= size
		if _, err := m.Amount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TokenMinAmount1.Size()
		i -= size
		if _, err := m.TokenMinAmount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TokenMinAmount0.Size()
		i -= size
		if _, err := m.TokenMinAmount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.Amount1.Size()
		i -= size
		if _, err := m.Amount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Amount0.Size()
		i -= size
		if _, err := m.Amount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddToPositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddToPositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddToPositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount1.Size()
		i -= size
		if _, err := m.Amount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Amount0.Size()
		i -= size
		if _, err := m.Amount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawPosition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawPosition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.LiquidityAmount.Size()
		i -= size
		if _, err := m.LiquidityAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.PositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawPositionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawPositionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawPositionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount1.Size()
		i -= size
		if _, err := m.Amount1.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount0.Size()
		i -= size
		if _, err := m.Amount0.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgCollectSpreadRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCollectSpreadRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCollectSpreadRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PositionIds) > 0 {
		dAtA2 := make([]byte, len(m.PositionIds)*10)
		var j1 int
		for _, num := range m.PositionIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTx(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCollectSpreadRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCollectSpreadRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCollectSpreadRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CollectedSpreadRewards) > 0 {
		for iNdEx := len(m.CollectedSpreadRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedSpreadRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgCollectIncentives) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCollectIncentives) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCollectIncentives) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PositionIds) > 0 {
		dAtA4 := make([]byte, len(m.PositionIds)*10)
		var j3 int
		for _, num := range m.PositionIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTx(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCollectIncentivesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCollectIncentivesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCollectIncentivesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ForfeitedIncentives) > 0 {
		for iNdEx := len(m.ForfeitedIncentives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ForfeitedIncentives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CollectedIncentives) > 0 {
		for iNdEx := len(m.CollectedIncentives) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CollectedIncentives[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgFungifyChargedPositions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFungifyChargedPositions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFungifyChargedPositions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PositionIds) > 0 {
		dAtA6 := make([]byte, len(m.PositionIds)*10)
		var j5 int
		for _, num := range m.PositionIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTx(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFungifyChargedPositionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFungifyChargedPositionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFungifyChargedPositionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewPositionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewPositionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreatePosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovTx(uint64(m.PoolId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.LowerTick != 0 {
		n += 1 + sovTx(uint64(m.LowerTick))
	}
	if m.UpperTick != 0 {
		n += 1 + sovTx(uint64(m.UpperTick))
	}
	if len(m.TokensProvided) > 0 {
		for _, e := range m.TokensProvided {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = m.TokenMinAmount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenMinAmount1.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreatePositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	l = m.Amount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Amount1.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LiquidityCreated.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.LowerTick != 0 {
		n += 1 + sovTx(uint64(m.LowerTick))
	}
	if m.UpperTick != 0 {
		n += 1 + sovTx(uint64(m.UpperTick))
	}
	return n
}

func (m *MsgAddToPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Amount1.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenMinAmount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenMinAmount1.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgAddToPositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	l = m.Amount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Amount1.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PositionId != 0 {
		n += 1 + sovTx(uint64(m.PositionId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.LiquidityAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgWithdrawPositionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount0.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Amount1.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCollectSpreadRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PositionIds) > 0 {
		l = 0
		for _, e := range m.PositionIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCollectSpreadRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollectedSpreadRewards) > 0 {
		for _, e := range m.CollectedSpreadRewards {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgCollectIncentives) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PositionIds) > 0 {
		l = 0
		for _, e := range m.PositionIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCollectIncentivesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CollectedIncentives) > 0 {
		for _, e := range m.CollectedIncentives {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.ForfeitedIncentives) > 0 {
		for _, e := range m.ForfeitedIncentives {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgFungifyChargedPositions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PositionIds) > 0 {
		l = 0
		for _, e := range m.PositionIds {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFungifyChargedPositionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewPositionId != 0 {
		n += 1 + sovTx(uint64(m.NewPositionId))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreatePosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerTick", wireType)
			}
			m.LowerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerTick |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperTick", wireType)
			}
			m.UpperTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperTick |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensProvided", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokensProvided = append(m.TokensProvided, types.Coin{})
			if err := m.TokensProvided[len(m.TokensProvided)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMinAmount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenMinAmount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMinAmount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenMinAmount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreatePositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityCreated", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityCreated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerTick", wireType)
			}
			m.LowerTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerTick |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperTick", wireType)
			}
			m.UpperTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperTick |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMinAmount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenMinAmount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenMinAmount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenMinAmount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddToPositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddToPositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddToPositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionId", wireType)
			}
			m.PositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LiquidityAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawPositionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawPositionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawPositionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount0", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount0.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCollectSpreadRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCollectSpreadRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCollectSpreadRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PositionIds = append(m.PositionIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositionIds) == 0 {
					m.PositionIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PositionIds = append(m.PositionIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCollectSpreadRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCollectSpreadRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCollectSpreadRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedSpreadRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedSpreadRewards = append(m.CollectedSpreadRewards, types.Coin{})
			if err := m.CollectedSpreadRewards[len(m.CollectedSpreadRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCollectIncentives) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCollectIncentives: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCollectIncentives: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PositionIds = append(m.PositionIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositionIds) == 0 {
					m.PositionIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PositionIds = append(m.PositionIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCollectIncentivesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCollectIncentivesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCollectIncentivesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectedIncentives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectedIncentives = append(m.CollectedIncentives, types.Coin{})
			if err := m.CollectedIncentives[len(m.CollectedIncentives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForfeitedIncentives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForfeitedIncentives = append(m.ForfeitedIncentives, types.Coin{})
			if err := m.ForfeitedIncentives[len(m.ForfeitedIncentives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFungifyChargedPositions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFungifyChargedPositions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFungifyChargedPositions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PositionIds = append(m.PositionIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositionIds) == 0 {
					m.PositionIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PositionIds = append(m.PositionIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositionIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFungifyChargedPositionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFungifyChargedPositionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFungifyChargedPositionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPositionId", wireType)
			}
			m.NewPositionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewPositionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
